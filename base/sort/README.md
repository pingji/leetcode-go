# Sort 排序

|   No | 目录       | 内容                     | 说明                 | Status | Revisited |
| ---: | ---------- | ------------------------ | -------------------- | ------ | --------- |
|    1 | insertsort | 插入排序                 |                      | Solved | Yes       |
|    2 | selectsort | 选择排序                 |                      | Solved | Yes       |
|    3 | mergesort1 | 自顶向下归并排序（递归） |                      | Solved | Yes       |
|    4 | mergesort2 | 自底向上归并排序（迭代） |                      | Solved | Yes       |
|    5 | quicksort1 | 单路快排                 | 大量重复的值排序较慢 | Solved | Yes       |
|    6 | quicksort2 | 两路快排                 | 大量重复的值排序很快 | Solved | Yes       |
|    7 | quicksort3 | 三路快排                 | 大量重复的值排序特快 | Solved | Yes       |


# 归并排序算法详解

## 1. 自顶向下归并排序（递归版本 - mergesort1）
**特点：**
- 使用递归分治的思想，自顶向下分解问题
- 将数组分为两半，分别排序后合并
- 合并策略：使用临时数组存储合并结果，避免覆盖原数组
- 时间复杂度：O(n log n)，空间复杂度：O(n)
- 稳定性：稳定排序算法

**适用场景：**
- 需要稳定排序的场景
- 对时间复杂度要求较高的场景
- 外部排序的基础算法

**优势：**
- 时间复杂度稳定，不受数据分布影响
- 适合处理大规模数据
- 可以并行化处理

**算法流程详解：**
- **分解阶段**：将数组递归地分成两半，直到每个子数组只有一个元素
- **合并阶段**：将两个有序子数组合并成一个有序数组
- **优化策略**：只有当左半部分的最大值大于右半部分的最小值时才需要合并

**合并过程详解：**
- 创建临时数组，复制原数组的 [l, r] 区间
- 维护两个指针 i 和 j，分别指向左半部分和右半部分的起始位置
- 比较两个指针指向的元素，将较小的元素放入原数组
- 当一个子数组遍历完毕后，直接将另一个子数组的剩余元素复制到原数组

**递归调用过程：**
- 计算中点 mid = (l + r) / 2
- 递归排序左半部分 [l, mid]
- 递归排序右半部分 [mid+1, r]
- 合并两个有序子数组 [l, mid] 和 [mid+1, r]

## 2. 自底向上归并排序（迭代版本 - mergesort2）
**特点：**
- 使用迭代的方式，自底向上构建有序数组
- 从长度为1的子数组开始，逐步合并成长度为2、4、8...的子数组
- 合并策略：与递归版本相同，使用临时数组
- 时间复杂度：O(n log n)，空间复杂度：O(n)
- 稳定性：稳定排序算法

**适用场景：**
- 需要避免递归调用栈溢出的场景
- 对空间效率要求较高的场景
- 适合在嵌入式系统或内存受限的环境中

**优势：**
- 避免了递归调用的开销
- 空间使用更加可控
- 适合处理超大规模数据

**算法流程详解：**
- **初始化**：将每个元素视为长度为1的有序子数组
- **迭代合并**：每次将相邻的两个有序子数组合并
- **步长递增**：步长从1开始，每次翻倍，直到覆盖整个数组

**合并过程详解：**
- 步长 step 从1开始，每次翻倍
- 遍历所有需要合并的子数组对
- 对于每对子数组 [i, i+step-1] 和 [i+step, min(i+2*step-1, len-1)]
- 调用相同的 merge 函数进行合并

**迭代控制过程：**
- 外层循环：控制步长 step，从1开始，每次翻倍
- 内层循环：遍历所有需要合并的子数组对
- 边界处理：确保第二个子数组存在，避免越界

## 性能比较

| 算法类型 | 时间复杂度 | 空间复杂度 | 稳定性 | 递归深度 | 适用场景 |
|---------|-----------|-----------|--------|---------|---------|
| 自顶向下归并排序 | O(n log n) | O(n) | 稳定 | O(log n) | 通用排序 |
| 自底向上归并排序 | O(n log n) | O(n) | 稳定 | 无递归 | 内存受限环境 |

## 合并策略对比

| 算法类型 | 分解方式 | 合并时机 | 内存使用 | 并行化潜力 |
|---------|---------|---------|---------|-----------|
| 自顶向下归并排序 | 递归分解 | 递归返回时 | 递归栈 + 临时数组 | 高（可并行化分解） |
| 自底向上归并排序 | 迭代分解 | 按步长合并 | 仅临时数组 | 中等（可并行化合并） |

## 优化策略

### 1. 合并优化
- **提前退出**：只有当左半部分的最大值大于右半部分的最小值时才需要合并
- **原地合并**：使用临时数组避免覆盖原数组，保证稳定性

### 2. 内存优化
- **临时数组复用**：在递归版本中，可以在函数开始时创建临时数组，避免重复分配
- **小数组优化**：当子数组长度较小时，可以使用插入排序等简单算法

### 3. 并行化优化
- **任务分解**：将大数组分解为多个小数组，并行处理
- **合并并行**：多个有序子数组可以并行合并

## 选择建议

1. **通用场景**：选择自顶向下归并排序（递归版本）
   - 代码简洁，易于理解和维护
   - 适合大多数排序需求

2. **内存受限环境**：选择自底向上归并排序（迭代版本）
   - 避免递归调用栈
   - 内存使用更加可控

3. **大规模数据处理**：优先考虑自底向上版本
   - 避免栈溢出风险
   - 更适合外部排序

4. **并行化需求**：两种版本都支持并行化
   - 自顶向下版本适合任务并行
   - 自底向上版本适合数据并行

## 与其他排序算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 原地排序 | 适用场景 |
|------|-----------|-----------|--------|---------|---------|
| 归并排序 | O(n log n) | O(n) | 稳定 | 否 | 稳定排序、外部排序 |
| 快速排序 | O(n log n) | O(log n) | 不稳定 | 是 | 通用排序、原地排序 |
| 堆排序 | O(n log n) | O(1) | 不稳定 | 是 | 原地排序、内存受限 |
| 插入排序 | O(n²) | O(1) | 稳定 | 是 | 小规模数据、部分有序 |


# 快速排序算法详解

## 1. 单路快排 (quicksort1)
**特点：**
- 使用快慢指针法进行分区
- 将数组分为两部分：小于基准元素的部分和大于等于基准元素的部分
- 分区策略：维护快指针i遍历数组，慢指针j指向小于基准元素区间的右边界
- 时间复杂度：平均 O(nlogn)，最坏 O(n²)
- 空间复杂度：O(logn)

**适用场景：**
- 数据分布相对均匀的情况
- 重复元素较少的数组

**缺点：**
- 对于包含大量重复元素的数组，性能会显著下降
- 重复元素会导致分区不平衡，退化为 O(n²) 时间复杂度

**分区过程详解：**
- 初始状态：基准元素在位置l，待处理区间为[l+1, r]
- 维护快慢指针：快指针i遍历数组，慢指针j指向小于基准元素区间的右边界
- 分区过程中维护3个区域：
  - [l+1, j]：小于基准元素的区域
  - [j+1, i-1]：大于等于基准元素的区域
  - [i, r]：待处理的区域
- 遍历区间[l+1, r]中的每个元素：
  - 如果元素小于基准元素：将其交换到j+1位置，j++
  - 如果元素大于等于基准元素：保持原位不动
- 最终结果：数组被分为两部分（小于基准元素 和 大于等于基准元素）
- 将基准元素放到正确位置（j位置）

**指针遍历过程：**
- 快指针i从l+1开始遍历整个数组，慢指针j初始化为l
- 快慢指针协同工作，维护3个区域：
  - 当nums[i] < nums[l]时：交换nums[j+1]和nums[i]，j++（慢指针前进，扩大小于区域）
  - 当nums[i] >= nums[l]时：i++（快指针前进，扩大大于等于区域）
- 遍历结束后，j指向小于区间的最后一个元素
- 最后交换nums[l]和nums[j]，将基准元素放到正确位置

## 2. 两路快排 (quicksort2)
**特点：**
- 使用双指针法进行分区，从两端向中间扫描
- 将数组分为三部分：小于基准元素、等于基准元素、大于基准元素
- 分区策略：左指针i向右扫描，右指针j向左扫描，交换不满足条件的元素
- 时间复杂度：平均 O(nlogn)，最坏 O(n²)
- 空间复杂度：O(logn)

**优势：**
- 相比单路快排，在处理重复元素时更高效
- 双指针法减少了不必要的交换操作
- 对于包含重复元素的数组，性能明显优于单路快排

**适用场景：**
- 包含一定数量重复元素的数组
- 需要稳定性能的排序场景

**分区过程详解：**
- 初始状态：基准元素在位置l，左指针i=l+1，右指针j=r
- 维护两个指针i和j，分别从两端向中间扫描
- 分区过程中维护3个区域：
  - [l+1, i)：小于等于基准元素的区域
  - (j, r]：大于等于基准元素的区域
  - [i, j]：待处理的区域
- 分区过程：
  - 左指针i向右扫描，找到第一个大于等于基准元素的元素
  - 右指针j向左扫描，找到第一个小于等于基准元素的元素
  - 如果i≤j，交换i和j位置的元素，然后i++，j--
  - 重复上述过程直到i>j
- 最终结果：数组被分为三部分（小于基准元素、等于基准元素、大于基准元素）
- 将基准元素放到正确位置（j位置）

**指针遍历过程：**
- 左指针i从l+1开始向右扫描，寻找第一个nums[i] >= v的元素
- 右指针j从r开始向左扫描，寻找第一个nums[j] <= v的元素
- 当找到不满足条件的元素时，交换nums[i]和nums[j]
- 交换后i++，j--，继续扫描，维护3个区域
- 当i > j时，分区完成，此时j指向小于等于基准元素的最后一个位置
- 最后交换nums[l]和nums[j]，将基准元素放到正确位置

## 3. 三路快排 (quicksort3)
**特点：**
- 使用三路分区法，将数组分为三部分：小于、等于、大于基准元素
- 专门针对包含大量重复元素的数组优化
- 分区策略：维护三个指针lt、i、gt，分别指向小于区间右边界、当前处理位置、大于区间左边界
- 时间复杂度：平均 O(nlogn)，最坏 O(n²)
- 空间复杂度：O(logn)

**优势：**
- 对于包含大量重复元素的数组，性能最优
- 避免了重复元素导致的性能退化问题
- 等于基准元素的部分无需再排序，直接跳过
- 在重复元素较多的情况下，时间复杂度接近 O(n)

**分区过程详解：**
- 初始状态：基准元素在位置l，待处理区间为[l+1, r]
- 维护三个指针：lt（小于区间右边界）、i（当前处理位置）、gt（大于区间左边界）
- 处理过程中分为4个区间：小于区间、等于区间、待处理区间、大于区间
- 最终结果：数组被分为3个部分（小于、等于、大于基准元素）

**指针遍历过程：**
- 指针初始化：lt=l（小于区间右边界），i=l+1（当前处理位置），gt=r+1（大于区间左边界）
- 遍历过程（while i < gt）：
  - 当nums[i] < v时：交换nums[lt+1]和nums[i]，lt++，i++
  - 当nums[i] == v时：i++（等于元素已在正确位置）
  - 当nums[i] > v时：交换nums[gt-1]和nums[i]，gt--（不移动i，因为交换后的元素还未处理）
- 遍历结束后，交换nums[l]和nums[lt]，将基准元素放到等于区间的开始位置
- 调整lt--，现在lt指向小于区间的最后一个元素

**适用场景：**
- 包含大量重复元素的数组
- 需要处理数据分布不均匀的情况
- 对性能要求较高的排序场景

## 性能比较

| 算法类型 | 最佳情况 | 平均情况 | 最坏情况 | 重复元素处理 | 空间复杂度 |
|---------|---------|---------|---------|-------------|-----------|
| 单路快排 | O(nlogn) | O(nlogn) | O(n²) | 较差 | O(logn) |
| 两路快排 | O(nlogn) | O(nlogn) | O(n²) | 良好 | O(logn) |
| 三路快排 | O(n) | O(nlogn) | O(n²) | 优秀 | O(logn) |

## 指针使用对比

| 算法类型 | 指针数量 | 指针名称 | 扫描方向 | 分区策略 |
|---------|---------|---------|---------|---------|
| 单路快排 | 2个 | i（快指针）, j（慢指针） | 单向（从左到右） | 快慢指针法 |
| 两路快排 | 3个 | i（左扫描）, j（右扫描）, v（基准值） | 双向（从两端向中间） | 双指针法 |
| 三路快排 | 4个 | lt（小于边界）, i（当前处理）, gt（大于边界）, v（基准值） | 单向（从左到右） | 三路分区法 |

## 选择建议

1. **数据分布均匀，重复元素少**：选择单路快排
2. **包含一定数量重复元素**：选择两路快排
3. **包含大量重复元素**：选择三路快排
4. **对性能要求极高**：优先考虑三路快排

