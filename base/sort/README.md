# Sort 排序

|   No | 目录       | 内容                     | 说明                 | Status | Revisited |
| ---: | ---------- | ------------------------ | -------------------- | ------ | --------- |
|    1 | insertsort | 插入排序                 |                      | Solved | Yes       |
|    2 | selectsort | 选择排序                 |                      | Solved | Yes       |
|    3 | mergesort1 | 自顶向下归并排序（递归） |                      | Solved | Yes       |
|    4 | mergesort2 | 自底向上归并排序（迭代） |                      | Solved | Yes       |
|    5 | quicksort1 | 单路快排                 | 大量重复的值排序较慢 | Solved | Yes       |
|    6 | quicksort2 | 两路快排                 | 大量重复的值排序很快 | Solved | Yes       |
|    7 | quicksort3 | 三路快排                 | 大量重复的值排序特快 | Solved | Yes       |

# 快速排序算法详解

## 1. 单路快排 (quicksort1)
**特点：**
- 使用快慢指针法进行分区
- 将数组分为两部分：小于基准元素的部分和大于等于基准元素的部分
- 分区策略：维护快指针i遍历数组，慢指针j指向小于基准元素区间的右边界
- 时间复杂度：平均 O(nlogn)，最坏 O(n²)
- 空间复杂度：O(logn)

**适用场景：**
- 数据分布相对均匀的情况
- 重复元素较少的数组

**缺点：**
- 对于包含大量重复元素的数组，性能会显著下降
- 重复元素会导致分区不平衡，退化为 O(n²) 时间复杂度

**分区过程详解：**
- 初始状态：基准元素在位置l，待处理区间为[l+1, r]
- 维护快慢指针：快指针i遍历数组，慢指针j指向小于基准元素区间的右边界
- 分区过程中维护3个区域：
  - [l+1, j]：小于基准元素的区域
  - [j+1, i-1]：大于等于基准元素的区域
  - [i, r]：待处理的区域
- 遍历区间[l+1, r]中的每个元素：
  - 如果元素小于基准元素：将其交换到j+1位置，j++
  - 如果元素大于等于基准元素：保持原位不动
- 最终结果：数组被分为两部分（小于基准元素 和 大于等于基准元素）
- 将基准元素放到正确位置（j位置）

**指针遍历过程：**
- 快指针i从l+1开始遍历整个数组，慢指针j初始化为l
- 快慢指针协同工作，维护3个区域：
  - 当nums[i] < nums[l]时：交换nums[j+1]和nums[i]，j++（慢指针前进，扩大小于区域）
  - 当nums[i] >= nums[l]时：i++（快指针前进，扩大大于等于区域）
- 遍历结束后，j指向小于区间的最后一个元素
- 最后交换nums[l]和nums[j]，将基准元素放到正确位置

## 2. 两路快排 (quicksort2)
**特点：**
- 使用双指针法进行分区，从两端向中间扫描
- 将数组分为三部分：小于基准元素、等于基准元素、大于基准元素
- 分区策略：左指针i向右扫描，右指针j向左扫描，交换不满足条件的元素
- 时间复杂度：平均 O(nlogn)，最坏 O(n²)
- 空间复杂度：O(logn)

**优势：**
- 相比单路快排，在处理重复元素时更高效
- 双指针法减少了不必要的交换操作
- 对于包含重复元素的数组，性能明显优于单路快排

**适用场景：**
- 包含一定数量重复元素的数组
- 需要稳定性能的排序场景

**分区过程详解：**
- 初始状态：基准元素在位置l，左指针i=l+1，右指针j=r
- 维护两个指针i和j，分别从两端向中间扫描
- 分区过程中维护3个区域：
  - [l+1, i)：小于等于基准元素的区域
  - (j, r]：大于等于基准元素的区域
  - [i, j]：待处理的区域
- 分区过程：
  - 左指针i向右扫描，找到第一个大于等于基准元素的元素
  - 右指针j向左扫描，找到第一个小于等于基准元素的元素
  - 如果i≤j，交换i和j位置的元素，然后i++，j--
  - 重复上述过程直到i>j
- 最终结果：数组被分为三部分（小于基准元素、等于基准元素、大于基准元素）
- 将基准元素放到正确位置（j位置）

**指针遍历过程：**
- 左指针i从l+1开始向右扫描，寻找第一个nums[i] >= v的元素
- 右指针j从r开始向左扫描，寻找第一个nums[j] <= v的元素
- 当找到不满足条件的元素时，交换nums[i]和nums[j]
- 交换后i++，j--，继续扫描，维护3个区域
- 当i > j时，分区完成，此时j指向小于等于基准元素的最后一个位置
- 最后交换nums[l]和nums[j]，将基准元素放到正确位置

## 3. 三路快排 (quicksort3)
**特点：**
- 使用三路分区法，将数组分为三部分：小于、等于、大于基准元素
- 专门针对包含大量重复元素的数组优化
- 分区策略：维护三个指针lt、i、gt，分别指向小于区间右边界、当前处理位置、大于区间左边界
- 时间复杂度：平均 O(nlogn)，最坏 O(n²)
- 空间复杂度：O(logn)

**优势：**
- 对于包含大量重复元素的数组，性能最优
- 避免了重复元素导致的性能退化问题
- 等于基准元素的部分无需再排序，直接跳过
- 在重复元素较多的情况下，时间复杂度接近 O(n)

**分区过程详解：**
- 初始状态：基准元素在位置l，待处理区间为[l+1, r]
- 维护三个指针：lt（小于区间右边界）、i（当前处理位置）、gt（大于区间左边界）
- 处理过程中分为4个区间：小于区间、等于区间、待处理区间、大于区间
- 最终结果：数组被分为3个部分（小于、等于、大于基准元素）

**指针遍历过程：**
- 指针初始化：lt=l（小于区间右边界），i=l+1（当前处理位置），gt=r+1（大于区间左边界）
- 遍历过程（while i < gt）：
  - 当nums[i] < v时：交换nums[lt+1]和nums[i]，lt++，i++
  - 当nums[i] == v时：i++（等于元素已在正确位置）
  - 当nums[i] > v时：交换nums[gt-1]和nums[i]，gt--（不移动i，因为交换后的元素还未处理）
- 遍历结束后，交换nums[l]和nums[lt]，将基准元素放到等于区间的开始位置
- 调整lt--，现在lt指向小于区间的最后一个元素

**适用场景：**
- 包含大量重复元素的数组
- 需要处理数据分布不均匀的情况
- 对性能要求较高的排序场景

## 性能比较

| 算法类型 | 最佳情况 | 平均情况 | 最坏情况 | 重复元素处理 | 空间复杂度 |
|---------|---------|---------|---------|-------------|-----------|
| 单路快排 | O(nlogn) | O(nlogn) | O(n²) | 较差 | O(logn) |
| 两路快排 | O(nlogn) | O(nlogn) | O(n²) | 良好 | O(logn) |
| 三路快排 | O(n) | O(nlogn) | O(n²) | 优秀 | O(logn) |

## 指针使用对比

| 算法类型 | 指针数量 | 指针名称 | 扫描方向 | 分区策略 |
|---------|---------|---------|---------|---------|
| 单路快排 | 2个 | i（快指针）, j（慢指针） | 单向（从左到右） | 快慢指针法 |
| 两路快排 | 3个 | i（左扫描）, j（右扫描）, v（基准值） | 双向（从两端向中间） | 双指针法 |
| 三路快排 | 4个 | lt（小于边界）, i（当前处理）, gt（大于边界）, v（基准值） | 单向（从左到右） | 三路分区法 |

## 选择建议

1. **数据分布均匀，重复元素少**：选择单路快排
2. **包含一定数量重复元素**：选择两路快排
3. **包含大量重复元素**：选择三路快排
4. **对性能要求极高**：优先考虑三路快排

