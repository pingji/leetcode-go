# Solutions

## Solution 1：归并排序

这道题目使用归并排序的思想来解决区间和的计数问题。主要思路如下:

### 1. 前缀和数组的定义

首先计算前缀和数组 `sum`，其中：
- `sum[0] = 0` (空数组的前缀和)
- `sum[i+1]` 表示前 i 个元素的和，即 `nums[0]` 到 `nums[i]` 的和

这样任意区间 `[i,j]` 的和可以通过 `sum[j+1] - sum[i]` 得到。

### 2. 分治统计策略

使用归并排序的框架，将问题分解为三个部分：

#### 2.1 子数组内部统计
- **左半部分内部**：统计区间和完全在左半部分 `[left, mid]` 内的个数
- **右半部分内部**：统计区间和完全在右半部分 `[mid+1, right]` 内的个数

#### 2.2 跨越子数组的统计
对于左半部分的每个前缀和 `sum[i]`，在右半部分中找到两个边界：
- `l`: 第一个满足 `sum[l] - sum[i] >= lower` 的位置
- `r`: 第一个满足 `sum[r] - sum[i] > upper` 的位置

则 `[l,r)` 范围内的所有位置 j 都满足 `lower <= sum[j] - sum[i] <= upper`，区间个数为 `r-l`。

### 3. count 变量的两次赋值

在 `merge` 函数中，`count` 变量有两次赋值：

#### 3.1 第一次赋值：初始化子数组内部计数
```go
count := n1 + n2
```
- `n1`：左半部分内部满足条件的区间和个数
- `n2`：右半部分内部满足条件的区间和个数
- 此时 `count` 只包含子数组内部的区间和个数

#### 3.2 第二次赋值：累加跨越子数组的计数
```go
count += (r - l)
```
- `r - l`：跨越左右两个子数组的区间和个数
- 最终 `count = n1 + n2 + (r - l)`，包含所有满足条件的区间和个数

### 4. 归并排序的必要性

在统计完区间个数后，需要将两个有序数组合并，保持前缀和数组的有序性，这对于下一轮统计是必要的。

### 复杂度分析

**时间复杂度**: O(nlogn)，其中 n 是数组长度。每一层需要 O(n) 的时间，共有 logn 层。

**空间复杂度**: O(n)，需要额外的数组来存储合并结果。
