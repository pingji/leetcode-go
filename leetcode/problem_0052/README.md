# Solutions

## solution 1：回溯

### 解题思路

N皇后II问题是N皇后I的变种，要求计算N皇后问题的所有可能解的数量，而不需要返回具体的解。

**与N皇后I的区别：**
- **N皇后I**：返回所有可能的解（字符串数组）
- **N皇后II**：只返回解的数量（整数）

**核心思想：**
1. **逐行放置**：每次只在一行放置一个皇后，避免同行冲突
2. **剪枝优化**：在放置前检查是否与已放置的皇后冲突
3. **回溯搜索**：当某个位置无法放置时，回退到上一步尝试其他位置
4. **计数而非记录**：找到解时只增加计数器，不保存具体解

**冲突检查：**
- **同行冲突**：检查当前行左侧是否已有皇后
- **同列冲突**：检查当前列上方是否已有皇后  
- **对角线冲突**：检查左上和右上对角线是否已有皇后
  - 左上对角线：`row-i == col-j` (左上对角线)
  - 右上对角线：`row-i == j-col` (右上对角线)

**算法步骤：**
1. 初始化n×n棋盘，所有位置设为"."
2. 从第0行开始，逐行尝试放置皇后
3. 对于每一行，遍历所有列位置
4. 检查当前位置是否有效（不与已放置的皇后冲突）
5. 如果有效，放置皇后并递归处理下一行
6. 如果无效或处理完所有行，回溯到上一步
7. 当放置完n个皇后时，计数器加1

**时间复杂度：** O(n!) - 最坏情况下需要尝试n!种排列
**空间复杂度：** O(n²) - 存储棋盘状态

**优化点：**
- 使用位运算可以进一步优化冲突检查
- 利用对称性可以减少一半的计算量
- 相比N皇后I，不需要存储具体解，内存使用更少
