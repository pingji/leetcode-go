# Solutions

## Solution 1：拓扑排序

### 解题思路

使用拓扑排序的思想来解决最长递增路径问题。核心思路是：**从出度为0的点开始，逐层处理，层数就是最长递增路径的长度**。

1. 先算出每个点的出度
2. 第一轮先取出度为0的点，并修改周围点的出度
3. 循环上一步直到所有点都取出
4. 计算循环次数

#### 算法步骤

1. **计算出度**
   - 遍历每个点，计算其出度（可以到达的更大值的邻居数量）
   - 出度为0的点是递增路径的终点

2. **初始化队列**
   - 将所有出度为0的点加入队列
   - 这些点作为第一层处理

3. **逐层处理**
   - 处理当前层的所有点
   - 对于每个点，检查其邻居（值更小的点）
   - 减少邻居的出度，如果邻居出度变为0，加入下一层
   - 每处理一层，路径长度+1

4. **返回结果**
   - 最终层数就是最长递增路径的长度

#### 时间复杂度：O(mn)，空间复杂度：O(mn)

---

## Solution 2：深度优先遍历

### 解题思路

使用记忆化DFS来解决最长递增路径问题。核心思路是：**从每个点开始DFS，使用记忆化避免重复计算**。

#### 算法步骤

1. **初始化记忆化数组**
   - `memo[i][j]` 表示从点(i,j)开始的最长递增路径长度
   - 初始化为0，表示未计算

2. **从每个点开始DFS**
   - 遍历矩阵中的每个点
   - 从每个点开始进行DFS搜索

3. **DFS搜索过程**
   - 如果已经计算过，直接返回记忆化结果
   - 初始长度为1（包含当前点）
   - 尝试四个方向，如果邻居值更大，递归搜索
   - 更新最长路径长度

4. **记忆化优化**
   - 避免重复计算相同的子问题
   - 大大提高算法效率

#### 时间复杂度：O(mn)，空间复杂度：O(mn)

#### 两种方法的比较
- **拓扑排序**：更直观，模拟了递增路径的构建过程
- **DFS**：更灵活，易于理解和实现，记忆化优化效果好

# References

